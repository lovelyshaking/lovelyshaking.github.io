---
layout: post
title: Exploit on TEE
---

***
　　2015 Blackhat USA上，来自360的Di Shen做了exploit trustzone of Huawei HiSilicon的报告。2014 Blackhat USA上，Dan Rosenberg做了名为Reflections on Trusting TrustZone的报告。在这篇博客中，我将综合这两篇文章做出一些自己的分析。
***

## 1.   Background

　　ARM TrustZone技术是可以应用在广泛设备上的系统性安全解决方案。可以应用在包括手机、平板、可穿戴设备等平台上。TrustZone主要被用于DRM，密钥存储、手机支付、secure boot管理、内核完整性监控等领域。
TrustZone将硬件和软件分为普通域和安全域两部分。普通域包括传统操作系统内核和与其相关的用户应用。安全域通常包括一个可信操作系统。安全域中运行的软件有访问全部软件和普通域的权限。普通域被隔离，不能访问TrustZone指定保护的设备总线和存储区域。普通域可以通过包括使用SMC（Secure Monitor Call）指令等向安全域提交请求。
由于TrustZone中存储的是高价值的目标，因此，对TrustZone的攻击很值得研究。

## 2.   What has done in Blackhat USA 2014

　　Dan Rosenberg的报告指出了一个影响使用高通骁龙芯片手机的TrustZone的漏洞。当时受这个漏洞影响的手机包括相当多的旗舰机，包括LG Nexus 4, LG Nexus 5, LG G2, HTC One 系列, Moto X, Samsung Galaxy S4, and Samsung Galaxy Note 3。   
　　造成这个漏洞的是由于SMC请求的边界检查的疏忽。拥有内核级别权限的攻击者可以构造SMC请求QSEE（Qualcomm's implementation of the Trusted Execution Environment）向任意安全内存写入受控制的数据。这可能被利用来在QSEE上下文中执行任意代码。  
　　普通域中的特权代码（如linux kernel code）可以使用SMC指令请求QSEE服务。QSEE支持2中使用SMC指令的调用：1）使用寄存器调用；2）使用提供参数的，如图1的结构的指令调用。在这个指令中，包含一个由普通域填充的request header和一个由QSEE在完成SMC请求之后填充的response header。  
　　![_config.yml]({{ site.baseurl }}/images/TEE_1.png)  
　　图1： 指令结构  
　　  
　　当QSEE收到使用命令结构的SMC请求时，会对request header做一些检查以保证这个请求是有效的。特别的，命令头被认为是有效的必须满足以下条件（通过对TrustZone镜像的逆向）：  
    
    1. req.len >= 16 (“指令长度是否大于指定的request header的长度？")
    2. req.buf_offset < req.len (“request buffer是否在指令内部")
    3. req.buf_offset >= 16 (“request buffer是否在request header之后开始？")
    4. qsee_is_ns_memory(req, req.len) == true (“整个命令buffer是否在非安全内存中？")
    5. req.resp_hdr_offset <= req.len - 16 (“整个response header是否在指令buffer中？")
    
　　在检查指令机构的完整性之后，QSEE识别并调用所需的SMC handler（如果存在的话）。在调用完成时，如果请求的输出需要input flag，QSEE将输出结构填充成以下形式：  
    
    rsp.len = 12;
    rsp.buf_offset = 12;
    *rsp.is_complete = 1;  
    
　　在这种情况下，response header的地址rsp由req+req.resp\_hdr\_offset计算得出。  
　　
qsee_is_ns_memory()函数（并不是函数的真实名字）被设计为检查某一范围内的内存被标记为“secure”且只能被TrustZone访问还是被标记为“non-secure”可以被linux 内核访问。这个函数有一个缺陷，就是不能正确的处理整数溢出。实际上当一个参数错误的比另一个参数大的时候，明确允许翻转参数的位置。以下是所涉及功能的近似伪代码：

    int qsee_is_ns_memory(long addr, long len)
    {
        return qsee_not_in_region(&region_list, addr, addr+len);
    }
    int qsee_not_in_region(void *list, long start, long end)
    {
        if (end < start) {
            tmp = start;
            start = end;
            end = tmp;
        }
    // Perform validation
    ...
    }
    
　　注意，如果qsee\_not\_in_region()调用时start的地址比end的地址大，函数就会翻转这两个参数的位置。因此，以下request header会导致QSEE向任意安全内存中写入构造的response header的三个word：0x0000000c 0x0000000c 0x00000001：  

    req.len = 0xfffff000
    req.buf_offset = 0xffffe000
    req.resp_hdr_offset = target C req
    
　　回看前面的验证过程，每个完整性检查都是成立的：  

    1. 0xfffff000 > 16
    2. 0xffffe000 < 0xfffff000
    3. 0xffffe000 >= 16
    4. qsee is ns memory(req, 0xfffff000) == true
    5. target - req < 0xfffff000 C 16
    
　　特别的，4满足是因为在调用qess\_not\_in_region()时指令buffer的地址与期望的长度相加时会出现整型溢出。但是这个函数之后会调换参数位置使得整个区域是有效的并且通过检查。
向任意安全内存中写入这三个word可以导致在QSEE上下文中执行任意代码。  
　　QSEE上下文中执行任意代码导致TrustZone安全性损失。特别是可以泄露敏感数据和破坏操作系统保护机制，使用可编程手段破坏secure boot。

## 3.   What has done in Blackhat 2015

　　Di Shen做了关于华为海思core的TEE的exploit的报告。海思的TEE与GP的TEE标准是兼容的。通过逆向，作者分析了它的架构：

　　![_config.yml]({{ site.baseurl }}/images/TEE_2.png)

　　TZDriver“/dev/tc\_ns\_client”是一个内核驱动，向用户区域的应用提供了与TEE OS交互的接口。跟QSEE的“/dev/qseecom”功能类似。两者的唯一区别是华为的每一个app都可以访问TZDriver但是qseecom只能被指定的系统进程访问。用户应用通过使用TCAPI与安全域进行通信。驱动文件的权限是“rw-rw-rw-”，SE context 是“u:object_r:device:s0”。 

　　TA表示可信应用，他们都是elf格式。“TEEGlobalTask”是TEE user模式的第一个TA。它能够加载elf模块，分派调用其他TA的请求。“RTOSck”是TEE内核，是华为开发的实时系统。指纹驱动在RTOSck中，指纹驱动只能被TA_FingerPrints访问，它帮助从传感器读取指纹数据。

　　应用使用TC\_NS\_ClientParam结构来向TEE驱动发送一个buffer指针。然后驱动向TEE发送SMC，将返回值copy到TC\_NS\_ClientParam指针中。

    typedef union {
        struct {
            unsigned int buffer; //ptr of buffer
            unsigned int offset; //size of buffer
            unsigned int size_addr;
        } memref;
        struct {
            unsigned int a_addr; //ptr of a 4-bytes buffer
            unsigned int b_addr; //ptr of a 4-bytes buffer
        } value;
    } TC_NS_ClientParam;


　　驱动在边界检查上出现了错误，伪代码如下：

    static int TC_NS_SMC_Call(TC_NS_ClientContext
        *client_context,TC_NS_DEV_File *dev_file, bool is_global){
        ....
        // build a TC_NS_SMC_CMD struct
        ....
        // execute SMC instruction
        TC_NS_SMC(smc_cmd_phys);
        // copy result from smc_cmd.operation_phys to callers'
        buffer(client_param.value)
        if(client_operation->params[0].value.a> 0xbfffffff){
            //driver think caller is from kernel space
            *(u32 *)client_param->value.a_addr = operation->params[i].value.a;
        }
        else{
            //driver think caller is from user space
            copy_to_user(....);
        }
        if(client_operation->params[0].value.b > 0xbfffffff){
            *(u32 *)client_param->value.b_addr = operation->params[i].value.b;
        }
        else{
            copy_to_user(....);
        }
        ....
    }

　　当应用程序向TrustZone驱动直接发送一个内核地址会发生什么？驱动会直接拷贝结果，而不是使用copy\_to\_user。这就为向内核写入任意数据提供了机会。  
　　
TEE OS中还有另一个漏洞。当执行SMC指令时，一个指向TC\_NS\_SMC\_CMD结构的指针会发送给TEE。一个恶意的TC\_NS\_SMC\_CMD会提供向几乎任意地址写入1byte的机会。因为在TEEGlobalTask 中没有边界检查，因此可以修改除了被TEE kernel使用的任意物理内存。

## 4.   Conclusion and What we can do

　　从以上漏洞可以看出，虽然TEE是为了解决安全问题而提出的，满足隔离的基本思想，但是任何的边界检查疏忽都可以导致TEE的功能被破坏。  
　　
那么，我们从这些案例中可以学习到什么？  

　　** 1. 我们可以看到，所有的这些exploit的前提都是对TrustZone image进行逆向。因此，可以通过对TrustZone image 进行一些加密手段来防止逆向。**

　　** 2. 对复杂数据结构的处理是漏洞的频发点。应该多加检查。可别要注意检查边界条件。**

　　** 3. 尽量减少攻击面。尽量不要向外提供过多过复杂的功能接口。**

　　** 4. 对于TEE os中的漏洞，TEE OS 应采用多种安全措施。如漏洞发现者发现海思的RTOSck中并没有ASLR, 没有DEP, 没有“r-x” .text section, 没有 stack canaries…几乎什么都没有只有一个传统的 RTOS内核。**

